-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simple SQL Parser
--   
--   Simple SQL Parser
@package sql-parser
@version 0.1.0.0


-- | A SQL parser implementation of the minimum required for a ODBC driver.
--   
--   <i>EBNF:</i>
--   
--   <pre>
--   character = ? any character ?;
--   
--   letter = lower-case-letter | upper-case-letter;
--   
--   lower-case-letter = 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' 
--                     | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' 
--                     | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' ;
--   
--   upper-case-letter = 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' 
--                     | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T'
--                     | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' ;
--   
--   digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;
--   </pre>
module Language.Sql.AST

-- | <i>EBNF:</i>
--   
--   <pre>
--   multiplication-operator = '*' | '/' ;
--   </pre>
data MultiplicationOperator
Multiply :: MultiplicationOperator
Divide :: MultiplicationOperator

-- | <i>EBNF:</i>
--   
--   <pre>
--   sign = '+' | '-' ;
--   </pre>
data Sign
Plus :: Sign
Minus :: Sign

-- | <i>EBNF:</i>
--   
--   <pre>
--   dynamic-parameter = '?' ;
--   </pre>
data DynamicParameter
DynamicParameter :: DynamicParameter

-- | <i>EBNF:</i>
--   
--   <pre>
--   comparison-operator = '&lt;' | '&gt;' | '&lt;=' | '&gt;=' | '=' | '&lt;&gt;' ;
--   </pre>
data ComparisonOperator
LessThan :: ComparisonOperator
GreaterThan :: ComparisonOperator
LessOrEqualTo :: ComparisonOperator
GreaterOrEqualTo :: ComparisonOperator
Equality :: ComparisonOperator
Inequality :: ComparisonOperator

-- | <i>EBNF:</i>
--   
--   <pre>
--   unsigned-integer = digit, { digit };
--   </pre>
newtype UnsignedInteger
UnsignedInteger :: Int -> UnsignedInteger

-- | <i>EBNF:</i>
--   
--   <pre>
--   literal = "'", { character - "'" | "''" }, "'";
--   </pre>
newtype Literal
Literal :: String -> Literal

-- | <i>EBNF:</i>
--   
--   <pre>
--   user-defined-name = letter, { digit | letter | '_' };
--   </pre>
newtype UserDefinedName
UserDefinedName :: String -> UserDefinedName

-- | <i>EBNF:</i>
--   
--   <pre>
--   table-identifier = user-defined-name;
--   </pre>
newtype TableIdentifier
TableIdentifier :: UserDefinedName -> TableIdentifier

-- | <i>EBNF:</i>
--   
--   <pre>
--   base-table-identifier = user-defined-name;
--   </pre>
newtype BaseTableIdentifier
BaseTableIdentifier :: UserDefinedName -> BaseTableIdentifier

-- | <i>EBNF:</i>
--   
--   <pre>
--   column-identifier = user-defined-name;
--   </pre>
newtype ColumnIdentifier
ColumnIdentifier :: UserDefinedName -> ColumnIdentifier

-- | <i>EBNF:</i>
--   
--   <pre>
--   table-name = table-identifier;
--   </pre>
newtype TableName
TableName :: TableIdentifier -> TableName

-- | <i>EBNF:</i>
--   
--   <pre>
--   column-name = [ table-name, '.' ], column-identifier;
--   </pre>
data ColumnName
ColumnName :: (Maybe TableName) -> ColumnIdentifier -> ColumnName

-- | <i>EBNF:</i>
--   
--   <pre>
--   base-table-name = base-table-identifier;
--   </pre>
newtype BaseTableName
BaseTableName :: BaseTableIdentifier -> BaseTableName

-- | <i>EBNF:</i>
--   
--   <pre>
--   table-reference = table-name;
--   </pre>
newtype TableReference
TableReference :: TableName -> TableReference

-- | <i>EBNF:</i>
--   
--   <pre>
--   table-reference-list = table-reference,  { ',', table-reference };    
--   </pre>
newtype TableReferenceList
TableReferenceList :: (NonEmpty TableReference) -> TableReferenceList

-- | <i>EBNF:</i>
--   
--   <pre>
--   sort-ordering = 'ASC' | 'DESC' ;
--   </pre>
data SortOrdering
Ascending :: SortOrdering
Descending :: SortOrdering

-- | <i>EBNF:</i>
--   
--   <pre>
--   sort-specification = (unsigned-integer | column-name), [ sort-ordering ];
--   </pre>
data SortSpecification
SortByColumnPosition :: UnsignedInteger -> (Maybe SortOrdering) -> SortSpecification
SortByColumnName :: ColumnName -> (Maybe SortOrdering) -> SortSpecification

-- | <i>EBNF:</i>
--   
--   <pre>
--   order-by-clause = 'ORDER', 'BY', sort-specification, { ',', sort-specification };
--   </pre>
newtype OrderByClause
OrderByClause :: (NonEmpty SortSpecification) -> OrderByClause

-- | <i>EBNF:</i>
--   
--   <pre>
--   data-type = 'char', '(', unsigned-integer, ')'
--             | 'varchar', '(', unsigned-integer, ')'
--             ;    
--   </pre>
data DataType
Char :: UnsignedInteger -> DataType
VarChar :: UnsignedInteger -> DataType

-- | <i>EBNF:</i>
--   
--   <pre>
--   expression = term, [ expression-op ];
--   </pre>
data Expression
Expression :: Term -> (Maybe ExpressionOp) -> Expression

-- | <i>EBNF:</i>
--   
--   <pre>
--   expression-op = sign, expression;
--   </pre>
data ExpressionOp
ExpressionOp :: Sign -> Expression -> ExpressionOp

-- | <i>EBNF:</i>
--   
--   <pre>
--   factor = [ sign ], primary;
--   </pre>
data Factor
Factor :: (Maybe Sign) -> Primary -> Factor

-- | <i>EBNF:</i>
--   
--   <pre>
--   term = factor, [ term-op ]
--   </pre>
data Term
Term :: Factor -> (Maybe TermOp) -> Term

-- | <i>EBNF:</i>
--   
--   <pre>
--   term-op = multiplication-operator, term
--   </pre>
data TermOp
TermOp :: MultiplicationOperator -> Term -> TermOp

-- | <i>EBNF:</i>
--   
--   <pre>
--   primary = column-name | dynamic-parameter | literal | '(', expression, ')';    
--   </pre>
data Primary
PrimaryColumnName :: ColumnName -> Primary
PrimaryDynamicParameter :: DynamicParameter -> Primary
PrimaryLiteral :: Literal -> Primary
PrimaryExpression :: Expression -> Primary

-- | <i>EBNF:</i>
--   
--   <pre>
--   select-sublist = expression;
--   </pre>
newtype SelectSubList
SelectSubList :: Expression -> SelectSubList

-- | <i>EBNF:</i>
--   
--   <pre>
--   (* select-list cannot contain parameters *)
--   select-list = '*'
--               | select-sublist, { ',', select-sublist }
--               ;
--   </pre>
data SelectList
SelectAll :: SelectList
SelectList :: (NonEmpty SelectSubList) -> SelectList

-- | <i>EBNF:</i>
--   
--   <pre>
--   insert-value = dynamic-parameter | literal | 'NULL' | 'USER' ;
--   </pre>
data InsertValue
InsertDynamicParameter :: DynamicParameter -> InsertValue
InsertLiteral :: Literal -> InsertValue
InsertNull :: InsertValue
InsertUser :: InsertValue

-- | <i>EBNF:</i>
--   
--   <pre>
--   comparison-predicate = expression, comparison-operator, expression;
--   </pre>
data ComparisonPredicate
ComparisonPredicate :: Expression -> ComparisonOperator -> Expression -> ComparisonPredicate

-- | <i>EBNF:</i>
--   
--   <pre>
--   not = 'not';
--   </pre>
data Not
Not :: Not

-- | <i>EBNF:</i>
--   
--   <pre>
--   boolean-factor = [ not ], boolean-primary;
--   </pre>
data BooleanFactor
BooleanFactor :: (Maybe Not) -> BooleanPrimary -> BooleanFactor

-- | <i>EBNF:</i>
--   
--   <pre>
--   boolean-primary = comparison-predicate
--                   | '(', search-condition, ')'
--                   ;
--   </pre>
data BooleanPrimary
BooleanPrimaryComparison :: ComparisonPredicate -> BooleanPrimary
BooleanPrimarySearch :: SearchCondition -> BooleanPrimary

-- | <i>EBNF:</i>
--   
--   <pre>
--   boolean-and = 'and', boolean-term;
--   </pre>
data BooleanAnd
BooleanAnd :: BooleanTerm -> BooleanAnd

-- | <i>EBNF:</i>
--   
--   <pre>
--   boolean-term = boolean-factor, [ boolean-and ];
--   </pre>
data BooleanTerm
BooleanTerm :: BooleanFactor -> (Maybe BooleanAnd) -> BooleanTerm

-- | <i>EBNF:</i>
--   
--   <pre>
--   boolean-or = 'or', search-condition;
--   </pre>
data BooleanOr
BooleanOr :: SearchCondition -> BooleanOr

-- | <i>EBNF:</i>
--   
--   <pre>
--   search-condition = boolean-term, [ boolean-or ];
--   </pre>
data SearchCondition
SearchCondition :: BooleanTerm -> (Maybe BooleanOr) -> SearchCondition

-- | <i>EBNF:</i>
--   
--   <pre>
--   distinct = 'DISTINCT';
--   </pre>
data Distinct
Distinct :: Distinct

-- | <i>EBNF:</i>
--   
--   <pre>
--   column-and-type = column-identifier, data-type;
--   </pre>
data ColumnAndType
ColumnAndType :: ColumnIdentifier -> DataType -> ColumnAndType

-- | <i>EBNF:</i>
--   
--   <pre>
--   create-table-statement = 'CREATE', 'TABLE', base-table-name, '(',
--                                column-and-type, { ',', column-and-type }
--                            ')'
--   </pre>
data CreateTable
CreateTable :: BaseTableName -> (NonEmpty ColumnAndType) -> CreateTable

-- | <i>EBNF:</i>
--   
--   <pre>
--   drop-table-statement = 'DROP', 'TABLE', base-table-name;
--   </pre>
data Drop
Drop :: BaseTableName -> Drop

-- | <i>EBNF:</i>
--   
--   <pre>
--   select-statement = 'SELECT', [ distinct ], select-list,
--                      'FROM' table-reference-list,
--                      ['WHERE' search-condition],
--                      [order-by-clause];
--   </pre>
data Select
Select :: (Maybe Distinct) -> SelectList -> TableReferenceList -> (Maybe SearchCondition) -> (Maybe OrderByClause) -> Select

-- | <i>EBNF:</i>
--   
--   <pre>
--   delete-statement-searched = 'DELETE', 'FROM', table-name
--                             , [ 'WHERE', search-condition ];
--   </pre>
data Delete
Delete :: TableName -> (Maybe SearchCondition) -> Delete

-- | Type alias for: <i>EBNF:</i>
--   
--   <pre>
--   column-identifier, { ',', column-identifier }
--   </pre>
type ColumnIdList = NonEmpty ColumnIdentifier

-- | Type alias for: <i>EBNF:</i>
--   
--   <pre>
--   insert-value, { ',', insert-value }
--   </pre>
type InsertValueList = NonEmpty InsertValue

-- | <i>EBNF:</i>
--   
--   <pre>
--   insert-statement = 'INSERT', 'INTO', table-name
--                    , [ '(', column-identifier, { ',', column-identifier } , ')' ],
--                    , 'VALUES', '(', insert-value, { ',', insert-value } ')'
--   </pre>
data Insert
Insert :: TableName -> (Maybe ColumnIdList) -> InsertValueList -> Insert

-- | <i>EBNF:</i>
--   
--   <pre>
--   update-value = expression | 'NULL';
--   </pre>
data UpdateValue
UpdateValueExpression :: Expression -> UpdateValue
UpdateValueNull :: UpdateValue

-- | <i>EBNF:</i>
--   
--   <pre>
--   update-column = column-identifier, '=', update-value;
--   </pre>
data UpdateColumn
UpdateColumn :: ColumnIdentifier -> UpdateValue -> UpdateColumn

-- | <i>EBNF:</i>
--   
--   <pre>
--   update-column-list = update-column, { ',', update-column };
--   </pre>
type UpdateColumnList = NonEmpty UpdateColumn

-- | <i>EBNF:</i>
--   
--   <pre>
--   update-statement-searched = 'UPDATE', table-name
--                             , 'SET', update-column-list
--                             , [ 'WHERE', search-condition ]
--                             ;
--   </pre>
data Update
Update :: TableName -> UpdateColumnList -> (Maybe SearchCondition) -> Update

-- | <i>EBNF:</i>
--   
--   <pre>
--   statement = create-table-statement
--             | delete-statement-searched
--             | drop-table-statement
--             | insert-statement
--             | select-statement
--             | update-statement-searched
--             ;
--   </pre>
data Statement
CreateStatement :: CreateTable -> Statement
DeleteStatement :: Delete -> Statement
DropStatement :: Drop -> Statement
InsertStatement :: Insert -> Statement
SelectStatement :: Select -> Statement
UpdateStatement :: Update -> Statement

-- | <i>EBNF:</i>
--   
--   <pre>
--   statement-list = statenment, { ';', statement };
--   </pre>
newtype StatementList
StatementList :: (NonEmpty Statement) -> StatementList
instance GHC.Show.Show Language.Sql.AST.StatementList
instance GHC.Show.Show Language.Sql.AST.Statement
instance GHC.Show.Show Language.Sql.AST.Update
instance GHC.Show.Show Language.Sql.AST.UpdateColumn
instance GHC.Show.Show Language.Sql.AST.UpdateValue
instance GHC.Show.Show Language.Sql.AST.Insert
instance GHC.Show.Show Language.Sql.AST.Delete
instance GHC.Show.Show Language.Sql.AST.Select
instance GHC.Show.Show Language.Sql.AST.Drop
instance GHC.Show.Show Language.Sql.AST.CreateTable
instance GHC.Show.Show Language.Sql.AST.ColumnAndType
instance GHC.Show.Show Language.Sql.AST.Distinct
instance GHC.Show.Show Language.Sql.AST.BooleanPrimary
instance GHC.Show.Show Language.Sql.AST.BooleanFactor
instance GHC.Show.Show Language.Sql.AST.BooleanAnd
instance GHC.Show.Show Language.Sql.AST.BooleanTerm
instance GHC.Show.Show Language.Sql.AST.BooleanOr
instance GHC.Show.Show Language.Sql.AST.SearchCondition
instance GHC.Show.Show Language.Sql.AST.Not
instance GHC.Show.Show Language.Sql.AST.ComparisonPredicate
instance GHC.Show.Show Language.Sql.AST.InsertValue
instance GHC.Show.Show Language.Sql.AST.SelectList
instance GHC.Show.Show Language.Sql.AST.SelectSubList
instance GHC.Show.Show Language.Sql.AST.ExpressionOp
instance GHC.Show.Show Language.Sql.AST.Factor
instance GHC.Show.Show Language.Sql.AST.TermOp
instance GHC.Show.Show Language.Sql.AST.Term
instance GHC.Show.Show Language.Sql.AST.Expression
instance GHC.Show.Show Language.Sql.AST.Primary
instance GHC.Show.Show Language.Sql.AST.DataType
instance GHC.Show.Show Language.Sql.AST.OrderByClause
instance GHC.Show.Show Language.Sql.AST.SortSpecification
instance GHC.Show.Show Language.Sql.AST.SortOrdering
instance GHC.Show.Show Language.Sql.AST.TableReferenceList
instance GHC.Show.Show Language.Sql.AST.TableReference
instance GHC.Show.Show Language.Sql.AST.BaseTableName
instance GHC.Show.Show Language.Sql.AST.ColumnName
instance GHC.Show.Show Language.Sql.AST.TableName
instance GHC.Show.Show Language.Sql.AST.ColumnIdentifier
instance GHC.Show.Show Language.Sql.AST.BaseTableIdentifier
instance GHC.Show.Show Language.Sql.AST.TableIdentifier
instance GHC.Show.Show Language.Sql.AST.UserDefinedName
instance GHC.Show.Show Language.Sql.AST.Literal
instance GHC.Show.Show Language.Sql.AST.UnsignedInteger
instance GHC.Show.Show Language.Sql.AST.ComparisonOperator
instance GHC.Show.Show Language.Sql.AST.DynamicParameter
instance GHC.Show.Show Language.Sql.AST.Sign
instance GHC.Show.Show Language.Sql.AST.MultiplicationOperator


-- | A SQL parser implementation of the minimum required for a ODBC driver.
module Language.Sql.Code
class Code a where scode x = ' ' : code x codes x = code x ++ " " scodes x = ' ' : code x ++ " "
code :: Code a => a -> String
scode :: Code a => a -> String
codes :: Code a => a -> String
scodes :: Code a => a -> String
sepList1 :: Code a => String -> NonEmpty a -> String
commaSepList1 :: Code a => NonEmpty a -> String
maybeCode :: Code a => Maybe a -> (String -> String) -> String
whereClause :: Maybe SearchCondition -> String
parens :: String -> String
instance Language.Sql.Code.Code a => Language.Sql.Code.Code (GHC.Base.Maybe a)
instance a ~ GHC.Types.Char => Language.Sql.Code.Code [a]
instance Language.Sql.Code.Code Language.Sql.AST.MultiplicationOperator
instance Language.Sql.Code.Code Language.Sql.AST.Sign
instance Language.Sql.Code.Code Language.Sql.AST.DynamicParameter
instance Language.Sql.Code.Code Language.Sql.AST.ComparisonOperator
instance Language.Sql.Code.Code Language.Sql.AST.UnsignedInteger
instance Language.Sql.Code.Code Language.Sql.AST.Literal
instance Language.Sql.Code.Code Language.Sql.AST.UserDefinedName
instance Language.Sql.Code.Code Language.Sql.AST.TableIdentifier
instance Language.Sql.Code.Code Language.Sql.AST.BaseTableIdentifier
instance Language.Sql.Code.Code Language.Sql.AST.ColumnIdentifier
instance Language.Sql.Code.Code Language.Sql.AST.TableName
instance Language.Sql.Code.Code Language.Sql.AST.ColumnName
instance Language.Sql.Code.Code Language.Sql.AST.BaseTableName
instance Language.Sql.Code.Code Language.Sql.AST.TableReference
instance Language.Sql.Code.Code Language.Sql.AST.TableReferenceList
instance Language.Sql.Code.Code Language.Sql.AST.SortOrdering
instance Language.Sql.Code.Code Language.Sql.AST.SortSpecification
instance Language.Sql.Code.Code Language.Sql.AST.OrderByClause
instance Language.Sql.Code.Code Language.Sql.AST.DataType
instance Language.Sql.Code.Code Language.Sql.AST.Expression
instance Language.Sql.Code.Code Language.Sql.AST.ExpressionOp
instance Language.Sql.Code.Code Language.Sql.AST.Factor
instance Language.Sql.Code.Code Language.Sql.AST.Term
instance Language.Sql.Code.Code Language.Sql.AST.TermOp
instance Language.Sql.Code.Code Language.Sql.AST.Primary
instance Language.Sql.Code.Code Language.Sql.AST.SelectSubList
instance Language.Sql.Code.Code Language.Sql.AST.SelectList
instance Language.Sql.Code.Code Language.Sql.AST.InsertValue
instance Language.Sql.Code.Code Language.Sql.AST.ComparisonPredicate
instance Language.Sql.Code.Code Language.Sql.AST.Not
instance Language.Sql.Code.Code Language.Sql.AST.BooleanFactor
instance Language.Sql.Code.Code Language.Sql.AST.BooleanPrimary
instance Language.Sql.Code.Code Language.Sql.AST.BooleanAnd
instance Language.Sql.Code.Code Language.Sql.AST.BooleanTerm
instance Language.Sql.Code.Code Language.Sql.AST.BooleanOr
instance Language.Sql.Code.Code Language.Sql.AST.SearchCondition
instance Language.Sql.Code.Code Language.Sql.AST.Distinct
instance Language.Sql.Code.Code Language.Sql.AST.ColumnAndType
instance Language.Sql.Code.Code Language.Sql.AST.CreateTable
instance Language.Sql.Code.Code Language.Sql.AST.Drop
instance Language.Sql.Code.Code Language.Sql.AST.Select
instance Language.Sql.Code.Code Language.Sql.AST.Delete
instance Language.Sql.Code.Code Language.Sql.AST.Insert
instance Language.Sql.Code.Code Language.Sql.AST.UpdateValue
instance Language.Sql.Code.Code Language.Sql.AST.UpdateColumn
instance Language.Sql.Code.Code Language.Sql.AST.Update
instance Language.Sql.Code.Code Language.Sql.AST.Statement
instance Language.Sql.Code.Code Language.Sql.AST.StatementList


-- | A SQL parser implementation of the minimum required for a ODBC driver.
module Language.Sql.AST.Tree
add :: AST a => Tree String -> a -> Tree String
addM :: AST a => Tree String -> Maybe a -> Tree String
addL :: AST a => Tree String -> NonEmpty a -> Tree String
addML :: AST a => Tree String -> Maybe (NonEmpty a) -> Tree String
class Code a => AST a where view = putStrLn . drawForest . forest forest = pure . tree leaf str x = Node str [pure $ code x] node str x = Node str [tree x] nodes str xs = Node str $ map tree $ toList xs
view :: AST a => a -> IO ()
forest :: AST a => a -> Forest String
tree :: AST a => a -> Tree String
leaf :: AST a => String -> a -> Tree String
node :: AST a => String -> a -> Tree String
nodes :: AST a => String -> NonEmpty a -> Tree String
instance a ~ GHC.Types.Char => Language.Sql.AST.Tree.AST [a]
instance Language.Sql.AST.Tree.AST Language.Sql.AST.MultiplicationOperator
instance Language.Sql.AST.Tree.AST Language.Sql.AST.Sign
instance Language.Sql.AST.Tree.AST Language.Sql.AST.DynamicParameter
instance Language.Sql.AST.Tree.AST Language.Sql.AST.ComparisonOperator
instance Language.Sql.AST.Tree.AST Language.Sql.AST.UnsignedInteger
instance Language.Sql.AST.Tree.AST Language.Sql.AST.Literal
instance Language.Sql.AST.Tree.AST Language.Sql.AST.UserDefinedName
instance Language.Sql.AST.Tree.AST Language.Sql.AST.TableIdentifier
instance Language.Sql.AST.Tree.AST Language.Sql.AST.BaseTableIdentifier
instance Language.Sql.AST.Tree.AST Language.Sql.AST.ColumnIdentifier
instance Language.Sql.AST.Tree.AST Language.Sql.AST.TableName
instance Language.Sql.AST.Tree.AST Language.Sql.AST.ColumnName
instance Language.Sql.AST.Tree.AST Language.Sql.AST.BaseTableName
instance Language.Sql.AST.Tree.AST Language.Sql.AST.TableReference
instance Language.Sql.AST.Tree.AST Language.Sql.AST.TableReferenceList
instance Language.Sql.AST.Tree.AST Language.Sql.AST.SortOrdering
instance Language.Sql.AST.Tree.AST Language.Sql.AST.SortSpecification
instance Language.Sql.AST.Tree.AST Language.Sql.AST.OrderByClause
instance Language.Sql.AST.Tree.AST Language.Sql.AST.DataType
instance Language.Sql.AST.Tree.AST Language.Sql.AST.Expression
instance Language.Sql.AST.Tree.AST Language.Sql.AST.ExpressionOp
instance Language.Sql.AST.Tree.AST Language.Sql.AST.Factor
instance Language.Sql.AST.Tree.AST Language.Sql.AST.Term
instance Language.Sql.AST.Tree.AST Language.Sql.AST.TermOp
instance Language.Sql.AST.Tree.AST Language.Sql.AST.Primary
instance Language.Sql.AST.Tree.AST Language.Sql.AST.SelectSubList
instance Language.Sql.AST.Tree.AST Language.Sql.AST.SelectList
instance Language.Sql.AST.Tree.AST Language.Sql.AST.InsertValue
instance Language.Sql.AST.Tree.AST Language.Sql.AST.ComparisonPredicate
instance Language.Sql.AST.Tree.AST Language.Sql.AST.Not
instance Language.Sql.AST.Tree.AST Language.Sql.AST.BooleanFactor
instance Language.Sql.AST.Tree.AST Language.Sql.AST.BooleanPrimary
instance Language.Sql.AST.Tree.AST Language.Sql.AST.BooleanAnd
instance Language.Sql.AST.Tree.AST Language.Sql.AST.BooleanTerm
instance Language.Sql.AST.Tree.AST Language.Sql.AST.BooleanOr
instance Language.Sql.AST.Tree.AST Language.Sql.AST.SearchCondition
instance Language.Sql.AST.Tree.AST Language.Sql.AST.Distinct
instance Language.Sql.AST.Tree.AST Language.Sql.AST.ColumnAndType
instance Language.Sql.AST.Tree.AST Language.Sql.AST.CreateTable
instance Language.Sql.AST.Tree.AST Language.Sql.AST.Drop
instance Language.Sql.AST.Tree.AST Language.Sql.AST.Select
instance Language.Sql.AST.Tree.AST Language.Sql.AST.Delete
instance Language.Sql.AST.Tree.AST Language.Sql.AST.Insert
instance Language.Sql.AST.Tree.AST Language.Sql.AST.UpdateValue
instance Language.Sql.AST.Tree.AST Language.Sql.AST.UpdateColumn
instance Language.Sql.AST.Tree.AST Language.Sql.AST.Update
instance Language.Sql.AST.Tree.AST Language.Sql.AST.Statement
instance Language.Sql.AST.Tree.AST Language.Sql.AST.StatementList


-- | A SQL parser implementation of the minimum required for a ODBC driver.
module Language.Sql.Parser
statementList :: Parser StatementList


-- | A SQL parser implementation of the minimum required for a ODBC driver.
module Language.Sql

-- | Parses a SQL statement into an AST
fromSql :: String -> Either (ParseError Char Dec) StatementList

-- | Generate a SQL Statement from an AST
toSql :: AST a => a -> String

-- | Prints the AST generated from a SQL Statment
ast :: String -> IO ()
